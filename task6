class Graph:
    def __init__(self, vertices):
        self.v = vertices
        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]

    # Check if assigning color c to vertex v is safe
    def is_safe(self, v, color, c):
        for i in range(self.v):
            if self.graph[v][i] == 1 and color[i] == c:
                return False
        return True

    # Utility function to assign colors recursively
    def graph_color_util(self, m, color, v):
        if v == self.v:  # all zones colored
            return True

        for c in range(1, m+1):
            if self.is_safe(v, color, c):
                color[v] = c
                if self.graph_color_util(m, color, v+1):
                    return True
                color[v] = 0  # backtrack
        return False

    # Main function to solve graph coloring
    def graph_coloring(self, m):
        color = [0] * self.v
        if not self.graph_color_util(m, color, 0):
            print("No valid traversal plan exists with", m, "colors.")
            return False

        print("Traversal plan exists with", m, "colors.")
        for zone, c in enumerate(color):
            print(f"Zone {zone+1} -> Signal Color {c}")
        return True


# Example: Warehouse graph (zones & connections)
if __name__ == "__main__":
    # Example: 5 zones in a warehouse
    g = Graph(5)

    # Define connections between zones
    g.graph = [[0, 1, 1, 0, 0],
               [1, 0, 1, 1, 0],
               [1, 1, 0, 1, 1],
               [0, 1, 1, 0, 1],
               [0, 0, 1, 1, 0]]

    m = 3
    
      # number of available signal colors
    g.graph_coloring(m)
